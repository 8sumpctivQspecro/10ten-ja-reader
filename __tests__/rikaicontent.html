<!doctype html>
<meta charset=utf-8>
<title>Tests for rikaicontent.js</title>
<link href="mocha/mocha.css" rel="stylesheet">
<script src="mocha/mocha.js"></script>
<script src="chai/chai.js"></script>

<!-- Mocks: these need to be defined before we load rikaicontent.js -->
<script>
const browser = {
  runtime: {
    sendMessage: msg => {
      // Probably should log this somewhere I guess...
    },
    onMessage: {
      addListener: fn => {
        // Probably should do something with this...
      },
    },
  },
};
browser.runtime.sendMessage({ type: 'enable?' });
</script>
<script src="../rikaicontent.js"></script>

<body>
<div id="mocha"></div>

<script>
mocha.setup('bdd');
const assert = chai.assert;

describe('rcxContent', () => {
  it('should exist', () => {
    assert.exists(window.rcxContent);
  });

  it('should format kanji entries', () => {
    const entry = {
      kanji: '士',
      misc: {
        B: '33',
        DK: '2129',
        E: '494',
        F: '526',
        G: '4',
        H: '3405',
        I: '3p0.1',
        IN: '572',
        L: '319',
        N: '1160',
        P: '4-3-2',
        S: '3',
        U: '58EB',
        V: '1117',
        Y: 'shi4',
      },
      miscDisplay: [
        { abbrev: 'H', name: 'Halpern' },
        { abbrev: 'L', name: 'Heisig' },
        { abbrev: 'E', name: 'Henshall' },
        { abbrev: 'DK', name: 'Kanji Learners Dictionary' },
        { abbrev: 'N', name: 'Nelson' },
        { abbrev: 'V', name: 'New Nelson' },
        { abbrev: 'Y', name: 'PinYin' },
        { abbrev: 'P', name: 'Skip Pattern' },
        { abbrev: 'IN', name: 'Tuttle Kanji & Kana' },
        { abbrev: 'I', name: 'Tuttle Kanji Dictionary' },
        { abbrev: 'U', name: 'Unicode' },
      ],
      onkun: ['シ'],
      nanori: ['お', 'ま'],
      bushumei: ['さむらい'],
      radical: '士',
      eigo: 'gentleman, samurai, samurai radical (no. 33)',
    };

    const result = window.rcxContent.makeHtmlForEntry(entry);
    assert.instanceOf(result, DocumentFragment);
    assert.strictEqual(result.childElementCount, 1,
                       'Should have one child element');

    const resultAsHtml = result.firstElementChild.outerHTML;

    // prettier-ignore
    assert.strictEqual(resultAsHtml,
      '<table class="k-main-tb"><tr><td valign="top"><table class="k-abox-tb"><tr><td class="k-abox-r">radical<br>士 33</td><td class="k-abox-g">grade<br>4</td></tr><tr><td class="k-abox-f">freq<br>526</td><td class="k-abox-s">strokes<br>3</td></tr></table><span class="k-kanji">士</span><br><div class="k-eigo">gentleman, samurai, samurai radical (no. 33)</div><div class="k-yomi">シ<br><span class="k-yomi-ti">名乗り</span> お、ま<br><span class="k-yomi-ti">部首名</span> さむらい</div></td></tr><tr><td><table class="k-mix-tb"><tr><td class="k-mix-td1">Halpern</td><td class="k-mix-td1">3405</td></tr><tr><td class="k-mix-td0">Heisig</td><td class="k-mix-td0">319</td></tr><tr><td class="k-mix-td1">Henshall</td><td class="k-mix-td1">494</td></tr><tr><td class="k-mix-td0">Kanji Learners Dictionary</td><td class="k-mix-td0">2129</td></tr><tr><td class="k-mix-td1">Nelson</td><td class="k-mix-td1">1160</td></tr><tr><td class="k-mix-td0">New Nelson</td><td class="k-mix-td0">1117</td></tr><tr><td class="k-mix-td1">PinYin</td><td class="k-mix-td1">shi4</td></tr><tr><td class="k-mix-td0">Skip Pattern</td><td class="k-mix-td0">4-3-2</td></tr><tr><td class="k-mix-td1">Tuttle Kanji &amp; Kana</td><td class="k-mix-td1">572</td></tr><tr><td class="k-mix-td0">Tuttle Kanji Dictionary</td><td class="k-mix-td0">3p0.1</td></tr><tr><td class="k-mix-td1">Unicode</td><td class="k-mix-td1">58EB</td></tr></table></td></tr></table>');
  });

  it('should format kanji entries with components', () => {
    const entry = {
      kanji: '鯖',
      misc: {
        B: '195',
        L: '2820',
        N: '5301',
        P: '1-11-8',
        U: '9BD6',
        S: '19',
        V: '6883',
        Y: 'qing1  zheng1',
      },
      miscDisplay: [
        { abbrev: 'H', name: 'Halpern' },
        { abbrev: 'U', name: 'Unicode' }
      ],
      components: [
        { radical: '魚', yomi: 'うお', english: 'fish' },
        { radical: '二', yomi: 'に', english: 'two' },
        { radical: '亠', yomi: 'なべぶた', english: 'lid' },
        { radical: '土', yomi: 'つち', english: 'earth' },
        { radical: '月', yomi: 'つき', english: 'moon' },
        { radical: '田', yomi: 'た', english: 'rice field' },
        { radical: '青', yomi: 'あお', english: 'blue' },
        { radical: '灬', yomi: 'れっか', english: 'fire' },
      ],
      onkun: ['セイ','ショウ','さば'],
      nanori: [],
      bushumei: [],
      radical: '魚',
      eigo: 'mackerel',
    };

    const result = window.rcxContent.makeHtmlForEntry(entry);
    assert.instanceOf(result, DocumentFragment);
    assert.strictEqual(result.childElementCount, 1,
                       'Should have one child element');

    const resultAsHtml = result.firstElementChild.outerHTML;

    // prettier-ignore
    assert.strictEqual(resultAsHtml,
      '<table class="k-main-tb"><tr><td valign="top"><table class="k-abox-tb"><tr><td class="k-abox-r">radical<br>魚 195</td><td class="k-abox-g">-</td></tr><tr><td class="k-abox-f">freq<br>-</td><td class="k-abox-s">strokes<br>19</td></tr></table><table class="k-bbox-tb"><tr><td class="k-bbox-1a">魚</td><td class="k-bbox-1b">うお</td><td class="k-bbox-1b">fish</td></tr><tr><td class="k-bbox-0a">二</td><td class="k-bbox-0b">に</td><td class="k-bbox-0b">two</td></tr><tr><td class="k-bbox-1a">亠</td><td class="k-bbox-1b">なべぶた</td><td class="k-bbox-1b">lid</td></tr><tr><td class="k-bbox-0a">土</td><td class="k-bbox-0b">つち</td><td class="k-bbox-0b">earth</td></tr><tr><td class="k-bbox-1a">月</td><td class="k-bbox-1b">つき</td><td class="k-bbox-1b">moon</td></tr><tr><td class="k-bbox-0a">田</td><td class="k-bbox-0b">た</td><td class="k-bbox-0b">rice field</td></tr><tr><td class="k-bbox-1a">青</td><td class="k-bbox-1b">あお</td><td class="k-bbox-1b">blue</td></tr><tr><td class="k-bbox-0a">灬</td><td class="k-bbox-0b">れっか</td><td class="k-bbox-0b">fire</td></tr></table><span class="k-kanji">鯖</span><br><div class="k-eigo">mackerel</div><div class="k-yomi">セイ、ショウ、さば</div></td></tr><tr><td><table class="k-mix-tb"><tr><td class="k-mix-td1">Halpern</td><td class="k-mix-td1">-</td></tr><tr><td class="k-mix-td0">Unicode</td><td class="k-mix-td0">9BD6</td></tr></table></td></tr></table>');
  });

  // TODO: Test above with a character with multiple readings
});

function assertRangeEqual(range, startContainer, startOffset,
                                 endContainer, endOffset) {
  assert.instanceOf(range, Range, 'Should have a range object');
  assert.strictEqual(range.startContainer, startContainer,
                     'startContainer node should match');
  assert.strictEqual(range.startOffset, startOffset,
                     'startOffset should match');
  assert.strictEqual(range.endContainer, endContainer,
                     'endContainer node should match');
  assert.strictEqual(range.endOffset, endOffset,
                     'endOffset should match');
}

function getBboxForOffset(node, start) {
  const range = new Range();
  range.setStart(node, start);
  range.setEnd(node, start+1);
  return range.getBoundingClientRect();
}

describe('rcxContent:text search', () => {
  let testDiv;

  beforeEach(() => {
    testDiv = document.createElement('div');
    testDiv.setAttribute('id', 'test-div');
    document.body.append(testDiv);
  });

  afterEach(() => {
    document.getElementById('test-div').remove();
  });

  it('should find a range in a div', () => {
    testDiv.append('あいうえお');
    const textNode = testDiv.firstChild;
    const bbox = getBboxForOffset(textNode, 0);

    const result =
      rcxContent.getRangeOrTextAtPoint(
        { x: bbox.right, y: bbox.top + bbox.height / 2 }
      );

    assertRangeEqual(result, textNode, 1, textNode, 5);
    assert.strictEqual(result.toString(), 'いうえお');
  });

  it('should find a range in a div when the point is part-way through a character', () => {
    testDiv.append('あいうえお');
    const textNode = testDiv.firstChild;
    const bbox = getBboxForOffset(textNode, 0);

    const result =
      rcxContent.getRangeOrTextAtPoint(
        { x: bbox.left + bbox.width / 2, y: bbox.top + bbox.height / 2 }
      );

    assertRangeEqual(result, textNode, 0, textNode, 5);
    assert.strictEqual(result.toString(), 'あいうえお');
  });

  it('should find a text in an inline sibling', () => {
    testDiv.append('あい');
    const span = document.createElement('span');
    span.append('うえ');
    testDiv.append(span);
    testDiv.append('お');
    const firstTextNode = testDiv.firstChild;
    const lastTextNode = testDiv.lastChild;
    const bbox = getBboxForOffset(firstTextNode, 0);

    const result =
      rcxContent.getRangeOrTextAtPoint(
        { x: bbox.right, y: bbox.top + bbox.height / 2 }
      );

    assertRangeEqual(result, firstTextNode, 1, lastTextNode, 1);
    assert.strictEqual(result.toString(), 'いうえお');
  });

  it('should NOT find a text in a block sibling', () => {
    testDiv.append('あい');
    const innerDiv = document.createElement('div');
    innerDiv.append('うえ');
    testDiv.append(innerDiv);
    testDiv.append('お');
    const firstTextNode = testDiv.firstChild;
    const bbox = getBboxForOffset(firstTextNode, 0);

    const result =
      rcxContent.getRangeOrTextAtPoint(
        { x: bbox.right, y: bbox.top + bbox.height / 2 }
      );

    assertRangeEqual(result, firstTextNode, 1, firstTextNode, 2);
    assert.strictEqual(result.toString(), 'い');
  });

  it('should find a text in a cousin for an inline node', () => {
  });

  it('should NOT find a text in a cousin for a block node', () => {
  });

  it('moves onto the next node if we are at the end of the current one', () => {
  });

  it('should ignore non-Japanese characters', () => {
  });

  it('should stop at non-Japanese characters', () => {
  });

  it('should stop at the maximum number of characters', () => {
  });

  it('should skip leading whitespace', () => {
  });

  it('should skip content in ruby elements', () => {
  });

  it('should find text in input elements', () => {
  });

  it('should find text in textarea elements', () => {
  });

  it('should pull the text out of a title attribute', () => {
  });

  it('should use the last result if there\'s no result but we haven\'t moved far', () => {
  });

  it('should NOT use the last result if there\'s no result and we\'ve moved far', () => {
  });
});

mocha.run();
</script>
</body>
